Frisbee :: blob {
    // A 3D position
    pos: [float]
    vel: [float]

    thrown: bool

    weight: float
    bounciness: float
    reusable: float
    accuracy: float

    update: fn float -> void
    draw: fn -> void
    out: fn -> bool
}

vel_from_mouse_pos :: fn -> [float] {
    WINDOW_DIM_X :: 500
    WINDOW_DIM_Y :: 500

    mouse_pos := l_mouse!

    x: !int = mouse_pos[0]
    y: !int = mouse_pos[1]

    SCALING :: 0.2

    ret [
        -as_float(x - WINDOW_DIM_X / 2) * SCALING,
        2.0,
        as_float(y - WINDOW_DIM_Y / 2) * SCALING,
    ]
}

sign :: fn x: float -> float {
    if x < 0.0 {
        ret -1.0
    }
    ret 1.0
}

new :: fn weight: float, bounciness: float, reusable: float, accuracy: float -> Frisbee {
    POS_SCALE :: -0.02
    OFFSET_Z :: 1.0
    OFFSET_Y :: -0.2
    
    self := Frisbee! {
        pos: [0.0, OFFSET_Y, OFFSET_Z]
        vel: [0.0, 0.0, 0.0]

        thrown: false

        weight: weight
        bounciness: bounciness
        reusable: reusable
        accuracy: accuracy

        update: fn delta: float -> void {}
        draw: fn -> void {}
        out: fn -> bool { ret true }
    }

    pos_from_vel :: fn vel: [float] -> [float] {
        ret [
            vel[0] * POS_SCALE,
            vel[1] * POS_SCALE + OFFSET_Y,
            vel[2] * POS_SCALE + OFFSET_Z,
        ]
    }

    self.update = fn delta: float -> void {
        if !self.thrown && l_input_down("hold") {
            self.vel = vel_from_mouse_pos!
            self.pos = pos_from_vel! self.vel
        }

        if !self.thrown && l_input_released("hold") {
            self.thrown = true
        }

        if self.thrown {
            self.pos[0] += self.vel[0] * delta
            self.pos[1] += self.vel[1] * delta
            self.pos[2] += self.vel[2] * delta

            if self.vel[2] < 0.0 {
                self.vel[0] -= self.pos[0] * self.weight * delta
            } else {
                self.vel[0] -= self.pos[0] * abs(self.pos[0]) * self.weight * delta
            }
            self.vel[1] -= self.pos[1] * self.weight * delta
            self.vel[2] -= self.pos[2] * self.weight * delta
        }
    }

    self.draw = fn -> void {
        pos := self.pos

        distance := sqrt! pos[2] * pos[2]
        l_gfx_rect! pos[0] / distance, pos[1] / distance, 0.5 / distance, 0.5 / distance, (0.5, 0.2, 0.2)
    }

    self.out = fn -> bool {
        distance := self.pos[2] * self.pos[2]
        ret distance < 1.0 && self.vel[2] < 0.0
    }

    ret self
}


