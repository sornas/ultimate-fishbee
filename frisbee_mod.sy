use game

Frisbee :: blob {
    // A 3D position
    pos: [float]
    vel: [float]

    thrown: bool

    weight: float
    bounciness: float
    reusable: float
    accuracy: float

    update: fn float -> void
    draw: fn -> void
    out: fn -> bool
}

vel_from_mouse_pos :: fn -> [float] {
    WINDOW_DIM_X :: 500
    WINDOW_DIM_Y :: 500

    mouse_pos := l_mouse!

    x: !int = mouse_pos[0]
    y: !int = mouse_pos[1]

    SCALING :: 0.2

    ret [
        -as_float(x - WINDOW_DIM_X / 2) * SCALING,
        2.0,
        as_float(y - WINDOW_DIM_Y / 2) * SCALING,
    ]
}

sign :: fn x: float -> float {
    if x < 0.0 {
        ret -1.0
    }
    ret 1.0
}

new :: fn weight: float, bounciness: float, reusable: float, accuracy: float -> Frisbee {
    POS_SCALE :: -0.02
    OFFSET_Z :: 1.0
    OFFSET_Y :: -0.2
    ANIM_TIME :: 0.25

    self := Frisbee! {
        pos: [0.0, OFFSET_Y, OFFSET_Z]
        vel: [0.0, 0.0, 0.0]

        thrown: false

        weight: weight
        bounciness: bounciness
        reusable: reusable
        accuracy: accuracy

        update: fn delta: float -> void {}
        draw: fn -> void {}
        out: fn -> bool { ret true }
    }

    pos_from_vel :: fn vel: [float] -> [float] {
        ret [
            vel[0] * POS_SCALE,
            vel[1] * POS_SCALE + OFFSET_Y,
            vel[2] * POS_SCALE + OFFSET_Z,
        ]
    }

    self.update = fn delta: float -> void {
        if !self.thrown && l_input_down("hold") {
            self.vel = vel_from_mouse_pos!
            self.pos = pos_from_vel! self.vel
        }

        if !self.thrown && l_input_released("hold") {
            self.thrown = true
        }

        if self.thrown {
            self.pos[0] += self.vel[0] * delta
            self.pos[1] += self.vel[1] * delta
            self.pos[2] += self.vel[2] * delta

            if self.vel[2] < 0.0 {
                self.vel[0] -= self.pos[0] * self.weight * delta
            } else {
                self.vel[0] -= self.pos[0] * abs(self.pos[0]) * self.weight * delta
            }
            self.vel[1] = 0.0
            self.vel[2] -= self.pos[2] * self.weight * delta
        }
    }

    self.draw = fn -> void {
        pos := self.pos

        accent := game.frisbee_accent(0, 0)
        time := rem! l_time(), ANIM_TIME
        if ANIM_TIME / 3.0 < time && time < ANIM_TIME * 2.0 / 3.0 {
            accent = game.frisbee_accent(0, 1)
        } else if ANIM_TIME * 2.0 / 3.0 <= time {
            accent = game.frisbee_accent(0, 2)
        }

        distance := abs! pos[2]
        si := (0, 0)
        scale := 0.5 / distance
        x_pos := pos[0] / distance
        y_pos := pos[1] / distance
        w := scale
        h := scale * 123.0 / 245.0
        color := (1.0, 0.5, 0.0)

        l_gfx_sprite! game.frisbee_base(), si, x_pos, y_pos, w, h, 0.0, color
        l_gfx_sprite! accent, si, x_pos, y_pos, w, h
        l_gfx_sprite! game.frisbee_shadow(), si, x_pos, y_pos, w, h
    }

    self.out = fn -> bool {
        distance := abs! self.pos[2]
        ret distance < 1.0 && self.vel[2] < 0.0
    }

    ret self
}


