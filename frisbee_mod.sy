use game

Frisbee :: blob {
    // A 3D position
    pos: [float]
    vel: [float]

    thrown: bool

    weight: float
    bounciness: float
    reusable: float
    accuracy: float

    update: fn float -> void
    draw: fn -> void
    draw_stacked: fn float, float, float -> void
    out: fn -> bool
}

vel_from_mouse_pos :: fn -> [float] {
    size := l_window_size!
    WINDOW_DIM_X: !int = size[0]
    WINDOW_DIM_Y: !int = size[1]

    mouse_pos := l_mouse!

    x: !int = mouse_pos[0]
    y: !int = mouse_pos[1]

    SCALING :: 0.2

    ret [
        clamp(-as_float(x - WINDOW_DIM_X / 2) * SCALING, -30.0, 30.0),
        2.0,
        clamp(as_float(y - WINDOW_DIM_Y / 2) * SCALING, 0.0, 30.0),
    ]
}

sign :: fn x: float -> float {
    if x < 0.0 {
        ret -1.0
    }
    ret 1.0
}

new :: fn weight: float, bounciness: float, reusable: float, accuracy: float -> Frisbee {
    POS_SCALE :: -0.02
    OFFSET_Z :: 1.0
    OFFSET_Y :: -0.2
    ANIM_TIME :: 0.25

    self := Frisbee! {
        pos: [0.0, OFFSET_Y, OFFSET_Z]
        vel: [0.0, 0.0, 0.0]

        thrown: false

        weight: weight
        bounciness: bounciness
        reusable: reusable
        accuracy: accuracy

        update: fn delta: float -> void {}
        draw: fn -> void {}
        draw_stacked: fn x: float, y: float, z: float -> void {}
        out: fn -> bool { ret true }
    }

    pos_from_vel :: fn vel: [float] -> [float] {
        ret [
            vel[0] * POS_SCALE,
            vel[1] * POS_SCALE + OFFSET_Y,
            vel[2] * POS_SCALE + OFFSET_Z,
        ]
    }

    get_style :: fn -> ((float, float, float), (float, float, float), int) {
        body := (0.3, 0.5, 0.3)
        if self.weight < 0.25 {
            body = (0.5, 0.3, 0.3)
        } else if self.weight > .75 {
            body = (0.5, 0.3, 0.5)
        }
        accent := (0.3, 0.5, 0.3)
        if self.bounciness < 0.25 {
            accent = (0.5, 0.3, 0.3)
        } else if self.bounciness > .75 {
            accent = (0.5, 0.3, 0.5)
        }
        accent *= body

        pattern := 0
        ret (body, accent, pattern)
    }

    self.update = fn delta: float -> void {
        if !self.thrown && l_input_down("hold") {
            self.vel = vel_from_mouse_pos!
            self.pos = pos_from_vel! self.vel
        }

        if !self.thrown && l_input_released("hold") {
            self.thrown = true
        }

        if self.thrown {
            self.pos[0] += self.vel[0] * delta
            self.pos[1] += self.vel[1] * delta
            self.pos[2] += self.vel[2] * delta

            if self.vel[2] < 0.0 {
                self.vel[0] -= self.pos[0] * self.weight * delta
            } else {
                self.vel[0] -= self.pos[0] * abs(self.pos[0]) * self.weight * delta
            }
            self.vel[1] = 0.0
            self.vel[2] -= self.pos[2] * self.weight * delta
        }
    }

    self.draw = fn -> void {
        pos := self.pos

        style := get_style()
        body_color : !(float, float, float) = style[0]
        accent_color : !(float, float, float) = style[1]
        pattern : !int = style[2]

        accent := game.frisbee_accent(pattern, 0)
        time := rem! l_time(), ANIM_TIME
        if ANIM_TIME / 3.0 < time && time < ANIM_TIME * 2.0 / 3.0 {
            accent = game.frisbee_accent(pattern, 1)
        } else if ANIM_TIME * 2.0 / 3.0 <= time {
            accent = game.frisbee_accent(pattern, 2)
        }

        distance := abs! pos[2]
        si := (0, 0)
        scale := 0.5 / distance
        x_pos := pos[0] / distance
        y_pos := pos[1] / distance
        w := scale
        h := scale * 123.0 / 245.0

        l_gfx_sprite! game.frisbee_base(), si, x_pos, y_pos, w, h, 0.0, body_color
        l_gfx_sprite! accent, si, x_pos, y_pos, w, h, 0.0, accent_color
        l_gfx_sprite! game.frisbee_shadow(), si, x_pos, y_pos, w, h
    }

    self.draw_stacked = fn x: float, y: float, z: float {
        pos := [x, y, z]

        style := get_style()
        body_color : !(float, float, float) = style[0]
        accent_color : !(float, float, float) = style[1]
        pattern : !int = style[2]

        accent := game.frisbee_accent(pattern, 0)

        distance := abs! pos[2]
        si := (0, 0)
        scale := 0.5 / distance
        x_pos := pos[0] / distance
        y_pos := pos[1] / distance
        w := scale
        h := scale * 123.0 / 245.0

        l_gfx_sprite! game.frisbee_base(), si, x_pos, y_pos, w, h, 0.0, body_color
        l_gfx_sprite! accent, si, x_pos, y_pos, w, h, 0.0, accent_color
        l_gfx_sprite! game.frisbee_shadow(), si, x_pos, y_pos, w, h
    }

    self.out = fn -> bool {
        distance := abs! self.pos[2]
        ret distance < 1.0 && self.vel[2] < 0.0
    }

    ret self
}

stack :: fn -> [Frisbee] {
    ret [new(1.0, 1.0, 1.0, 1.0)]
}

