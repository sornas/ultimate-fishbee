use game

Fish :: blob {
    value: int
    pos: [float]
    speed: [float]
    height: int
    layer: int
    time: float

    update: fn float -> void
    draw: fn -> void
}

fish_new :: fn pos: [float] -> Fish {

    PI := 3.1415
    FISH_INIT_SPEED :: 2.5
    FISH_ANIM_TIME :: 0.3

    angle := l_random_range! PI * 2.0 / 5.0, PI * 3.0 / 5.0

    fish :: Fish! {
        value: 0,
        pos: pos,
        speed: [FISH_INIT_SPEED * cos(angle), FISH_INIT_SPEED * sin(angle)],
        height: 0,
        layer: 0,
        time: 0.0,
        update: fn delta: float {},
        draw: fn {},
    }

    fish.update = fn delta: float {
        fish.pos[0] += fish.speed[0] * delta
        fish.pos[1] += fish.speed[1] * delta

        fish.speed[1] += -3.0 * delta

        fish.time += delta
        if fish.time > FISH_ANIM_TIME {
            fish.time -= FISH_ANIM_TIME
        }
    }

    fish.draw = fn {
        sprite := game.fish_frame(0)
        if FISH_ANIM_TIME / 3.0 < fish.time && fish.time < FISH_ANIM_TIME * 2.0 / 3.0 {
            sprite = game.fish_frame(1)
        } else if FISH_ANIM_TIME * 2.0 / 3.0 <= fish.time {
            sprite = game.fish_frame(2)
        }
        l_gfx_sprite! sprite, (0, 0), fish.pos[0], fish.pos[1], 1.0, 123.0 / 245.0
    }

    ret fish
}

fish_filter :: fn fishes: [Fish] -> [Fish] {
    valid_i := -1
    for i := 0, i < len(fishes), i += 1 {
        if fishes[i].pos[1] > -20.0 {
            valid_i = i
            break
        }
    }

    if valid_i == -1 {
        ret [fish_new([-100.0, -100.0])]
    }

    new_fishes := [fishes[valid_i]]
    for i := valid_i + 1, i < len(fishes), i += 1 {
        if fishes[i].pos[1] > -20.0 {
            push! new_fishes, fishes[i]
        }
    }
    ret new_fishes
}

