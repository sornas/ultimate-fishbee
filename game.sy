use fish_mod
use frisbee_mod
use store_mod

fish_dims := [
    (91, 236),
    (200, 300),
    (105, 241),
]

fish_frames := [
    l_load_image("res/fish1_1.png", (91, 236)),
    l_load_image("res/fish1_2.png", (91, 236)),
    l_load_image("res/fish1_3.png", (91, 236)),

    l_load_image("res/fish2_1.png", (200, 300)),
    l_load_image("res/fish2_2.png", (200, 300)),
    l_load_image("res/fish2_3.png", (200, 300)),

    l_load_image("res/fish3_1.png", (105, 241)),
    l_load_image("res/fish3_2.png", (105, 241)),
    l_load_image("res/fish3_3.png", (105, 241)),
]

fish_frame :: fn index: int, frame: int -> ((str, int), float) {
    w : !int = fish_dims[index][0]
    h : !int = fish_dims[index][1]
    ret (fish_frames[index * 3 + frame], as_float(h) / as_float(w))
}

fishes := fish_mod.fish_list!
frisbee_stack := frisbee_mod.stack!
frisbee := frisbee_mod.new! 1.0, 1.0, 1.0, 1.0
out_of_frisbees := false

GAME_STATE_PLAYING := 0
GAME_STATE_STORE := 1
// GAME_STATE_MENU := 2

game_state := 0

set_game_state :: fn state: int {
    game_state = state
}

frisbee_accents := [
    [
        l_load_image("res/frisbee_spikes1.png", (245, 123)),
        l_load_image("res/frisbee_spikes2.png", (245, 123)),
        l_load_image("res/frisbee_spikes3.png", (245, 123)),
    ],
    [
        l_load_image("res/frisbee_dots1.png", (245, 123)),
        l_load_image("res/frisbee_dots2.png", (245, 123)),
        l_load_image("res/frisbee_dots3.png", (245, 123)),
    ],
    [
        l_load_image("res/frisbee_wave1.png", (245, 123)),
        l_load_image("res/frisbee_wave2.png", (245, 123)),
        l_load_image("res/frisbee_wave3.png", (245, 123)),
    ],
]

_frisbee_base :: l_load_image("res/frisbee_base.png", (245, 123))
_frisbee_shadow :: l_load_image("res/frisbee_shadow.png", (245, 123))

frisbee_base :: fn -> (str, int) {
    ret _frisbee_base
}

frisbee_shadow :: fn -> (str, int) {
    ret _frisbee_shadow
}

frisbee_accent :: fn type: int, index: int -> (str, int) {
    ret frisbee_accents[type][index]
}

money := 25

pay :: fn price: int -> bool {
    if price <= money {
        money -= price
        ret true
    }
    ret false
}

buy_frisbee :: fn weight: float, bounciness: float, reusable: float, accuracy: float -> void {
    push! frisbee_stack, frisbee_mod.new(weight, bounciness, reusable, accuracy)
}

init :: fn {
    pop! frisbee_stack

    buy_frisbee! 1.0, 1.0, 1.0, 1.0
    buy_frisbee! 1.0, 1.0, 1.0, 1.0
    buy_frisbee! 1.0, 1.0, 1.0, 1.0

    l_bind_quit("quit")
    l_bind_key("ESCAPE", "quit")

    l_bind_mouse! "left", "hold"
    l_bind_key! "e", "hold"

    l_bind_key! "s", "store"
}

update_game :: fn delta: float -> void {

    if !out_of_frisbees {
        frisbee.update! delta
    }

    if l_input_down("store") {
        game_state = GAME_STATE_STORE
    }

    i := 0
    for q := 0, i < len(fishes), i += 1 {
        q
        fish := fishes[i]
        fish.update! delta

        if frisbee.thrown {
            fish_pos := fish.world_pos!
            delta := [
                fish_pos[0] - frisbee.pos[0],
                0.0, // fish_pos[1] - frisbee.pos[1], // don't check y
                fish_pos[2] - frisbee.pos[2],
            ]

            distance := sqrt! delta[0] * delta[0] + delta[1] * delta[1] + delta[2] * delta[2]
            if distance < 0.4 {
                frisbee.vel[0] *= -1.0 * frisbee.bounciness
                fish.hit!
                money += fish.value
                print "MONEY:"
                print money
            }
        }
    }
    fishes = fish_mod.fish_filter! fishes

    // Spawn fish
    if l_random() < 0.03 {
        width := 8.0
        push! fishes, fish_mod.fish_new([l_random() * width - width / 2.0, 0.0], l_random_range(0, 2))
    }

    if frisbee.out() {
        if frisbee.broken() {
            if len(frisbee_stack) > 0 {
                frisbee = pop! frisbee_stack
                out_of_frisbees = false
            } else {
                out_of_frisbees = true
            }
        } else {
            frisbee.reset!
        }
    }
}

draw_game :: fn {
    for layer := 0, layer < 3, layer += 1 {
        for i := 0, i < len(fishes), i += 1 {
            if fishes[i].layer == layer {
                fishes[i].draw!
            }
        }
    }

    stack_x := -0.65
    stack_y := -0.8

    for i := 0, i < len(frisbee_stack), i += 1 {
        y := stack_y + 0.1 * as_float(i)
        f := frisbee_stack[i]
        f.draw_stacked! stack_x, y, 1.0
    }

    if !out_of_frisbees {
        frisbee.draw!
    }
}

start :: fn {
    print "start!"
    init!

    fs := store_mod.store_init!

    init_store : !fn -> void = fs[0]
    update_store : !fn float -> void = fs[1]
    draw_store : !fn -> void = fs[2]

    init_store!

    for _ in inf(0) {
        _
        if l_input_down("quit") {
            break
        }

        l_update!

        if game_state == GAME_STATE_PLAYING {
            update_game! l_delta!
            draw_game!
        }
        if game_state == GAME_STATE_STORE {
            update_store! l_delta()
            draw_store!
        }

        l_render!
    }
}
