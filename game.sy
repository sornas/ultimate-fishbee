use fish_mod
use frisbee_mod

fish_frames := [
    l_load_image("src/res/frisbee_spikes1.png", (245, 123)),
    l_load_image("src/res/frisbee_spikes2.png", (245, 123)),
    l_load_image("src/res/frisbee_spikes3.png", (245, 123)),
]

fish_frame :: fn index: int -> (str, int) {
    ret fish_frames[index]
}

fishes := fish_mod.fish_list!
frisbee := frisbee_mod.new! 1.0, 1.0, 1.0, 1.0

init :: fn {
    l_bind_quit("quit")
    l_bind_key("ESCAPE", "quit")

    l_bind_mouse! "left", "hold"
    l_bind_key! "e", "hold"


    for i := 0, i < 2, i += 1 {
        push! fishes, fish_mod.fish_new([0.0, 0.0], 0)
    }
}

update :: fn delta: float -> void {

    frisbee.update! delta

    i := 0
    for q := 0, i < len(fishes), i += 1 {
        q
        fish := fishes[i]
        fish.update! delta

        if frisbee.thrown {
            fish_pos := fish.world_pos!
            delta := [
                fish_pos[0] - frisbee.pos[0],
                0.0, // fish_pos[1] - frisbee.pos[1], // don't check y
                fish_pos[2] - frisbee.pos[2],
            ]

            distance := sqrt! delta[0] * delta[0] + delta[1] * delta[1] + delta[2] * delta[2]
            if distance < 0.3 {
                frisbee.vel[0] *= -1.0 * frisbee.bounciness
                fish.hit!
                print "HIT!"
            }
        }
    }
    fishes = fish_mod.fish_filter! fishes

    if frisbee.out() {
        frisbee = frisbee_mod.new! 1.0, 1.0, 1.0, 1.0
    }
}

draw :: fn {
    for layer := 0, layer < 3, layer += 1 {
        //if layer == 0 {
        //    l_gfx_rect! (0.0, 0.0), (1.0, 1.0), (0.5, 0.5, 0.5)
        //}
        for i := 0, i < len(fishes), i += 1 {
            if fishes[i].layer == layer {
                fishes[i].draw!
            }
        }
    }

    frisbee.draw!
}

start :: fn {
    print "start!"
    init!

    for _ in inf(0) {
        _
        if l_input_down("quit") {
            break
        }

        l_update!
        update! l_delta!

        draw!
        l_render!
    }
}
