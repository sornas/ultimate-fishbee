use fish_mod
use font_mod
use frisbee_mod
use store_mod
use curtain_mod

font_sprite := l_load_image("src/res/font.png", (11, 11))
font :: fn -> (str, int) {
    ret font_sprite
}

FONT_DOLLAR    := 0
FONT_PLUS      := 1
// FONT_MINUS     := 2
// FONT_QUESTION  := 3

fish_dims := [
    (91, 236),
    (200, 300),
    (105, 241),
]

fish_frames := [
    l_load_image("res/fish1_1.png", (91, 236)),
    l_load_image("res/fish1_2.png", (91, 236)),
    l_load_image("res/fish1_3.png", (91, 236)),

    l_load_image("res/fish2_1.png", (200, 300)),
    l_load_image("res/fish2_2.png", (200, 300)),
    l_load_image("res/fish2_3.png", (200, 300)),

    l_load_image("res/fish3_1.png", (105, 241)),
    l_load_image("res/fish3_2.png", (105, 241)),
    l_load_image("res/fish3_3.png", (105, 241)),
]

fish_frame :: fn index: int, frame: int -> ((str, int), float) {
    w : !int = fish_dims[index][0]
    h : !int = fish_dims[index][1]
    ret (fish_frames[index * 3 + frame], as_float(h) / as_float(w))
}

fishes := fish_mod.fish_list!
frisbee_stack := frisbee_mod.stack!
frisbee := frisbee_mod.new! 1.0, 1.0, 1.0, 1.0
out_of_frisbees := false

GAME_STATE_PLAYING := 0
GAME_STATE_STORE := 1
// GAME_STATE_MENU := 2

game_state := 0

set_game_state :: fn state: int {
    game_state = state
}

frisbee_accents := [
    [
        l_load_image("res/frisbee_spikes1.png", (245, 123)),
        l_load_image("res/frisbee_spikes2.png", (245, 123)),
        l_load_image("res/frisbee_spikes3.png", (245, 123)),
    ],
    [
        l_load_image("res/frisbee_dots1.png", (245, 123)),
        l_load_image("res/frisbee_dots2.png", (245, 123)),
        l_load_image("res/frisbee_dots3.png", (245, 123)),
    ],
    [
        l_load_image("res/frisbee_wave1.png", (245, 123)),
        l_load_image("res/frisbee_wave2.png", (245, 123)),
        l_load_image("res/frisbee_wave3.png", (245, 123)),
    ],
]

_frisbee_base :: l_load_image("res/frisbee_base.png", (245, 123))
_frisbee_shadow :: l_load_image("res/frisbee_shadow.png", (245, 123))

frisbee_base :: fn -> (str, int) {
    ret _frisbee_base
}

frisbee_shadow :: fn -> (str, int) {
    ret _frisbee_shadow
}

frisbee_accent :: fn type: int, index: int -> (str, int) {
    ret frisbee_accents[type][index]
}

_curtain_full :: l_load_image("res/curtain_full.png", (512, 512))
_curtain_edge :: l_load_image("res/curtain_edge.png", (512, 512))

curtain_full :: fn -> (str, int) {
    ret _curtain_full
}

curtain_edge :: fn -> (str, int) {
    ret _curtain_edge
}

curtain_pos := 2.0
curtain_vel := 0.0
_curtain_on_complete := fn {}

get_curtain_pos :: fn -> float {
    ret curtain_pos
}

set_curtain_pos :: fn pos: float {
    curtain_pos = pos
}

get_curtain_vel :: fn -> float {
    if game_state == GAME_STATE_STORE {
        ret curtain_vel * 2.0
    }
    ret curtain_vel
}

set_curtain_vel :: fn vel: float {
    curtain_vel = vel
}

curtain_on_complete :: fn {
    _curtain_on_complete()
}

start_transition :: fn down: bool, on_complete: fn -> void {
    if down {
        curtain_vel = -1.0
    } else {
        curtain_vel = 1.0
    }
    _curtain_on_complete = on_complete
}

money := 25

pay :: fn price: int -> bool {
    if price <= money {
        money -= price
        ret true
    }
    ret false
}

buy_frisbee :: fn weight: float, bounciness: float, reusable: float, accuracy: float -> void {
    push! frisbee_stack, frisbee_mod.new(weight, bounciness, reusable, accuracy)
}

init :: fn {
    pop! frisbee_stack

    buy_frisbee! 1.0, 1.0, 1.0, 1.0
    buy_frisbee! 1.0, 1.0, 1.0, 1.0
    buy_frisbee! 1.0, 1.0, 1.0, 1.0

    l_bind_quit("quit")
    l_bind_key("ESCAPE", "quit")

    l_bind_mouse! "left", "hold"
    l_bind_key! "e", "hold"

    l_bind_key! "s", "store"
}

update_game :: fn delta: float -> void {

    if !out_of_frisbees {
        frisbee.update! delta
    }

    if l_input_down("store") {
        on_complete := fn {
            set_game_state(1)
        }
        start_transition! true, on_complete
    }

    i := 0
    for q := 0, i < len(fishes), i += 1 {
        q
        fish := fishes[i]
        fish.update! delta

        if frisbee.thrown {
            fish_pos := fish.world_pos!
            delta := [
                fish_pos[0] - frisbee.pos[0],
                0.0, // fish_pos[1] - frisbee.pos[1], // don't check y
                (fish_pos[2] - frisbee.pos[2]) * 0.3,
            ]

            distance := sqrt! delta[0] * delta[0] + delta[1] * delta[1] + delta[2] * delta[2]
            if distance < 0.5 {
                frisbee.vel[0] *= -1.0 * frisbee.bounciness
                fish.hit!
                money += fish.value
                print "MONEY:"
                print money
            }
        }
    }
    fishes = fish_mod.fish_filter! fishes

    // Spawn fish
    if l_random() < 0.03 {
        width := 8.0
        push! fishes, fish_mod.fish_new([l_random() * width - width / 2.0 + 3.0, -3.0], l_random_range(0, 2))
    }

    if frisbee.out() {
        if frisbee.broken() {
            if len(frisbee_stack) > 0 {
                frisbee = pop! frisbee_stack
                out_of_frisbees = false
            } else {
                out_of_frisbees = true
            }
        } else {
            frisbee.reset!
        }
    }
}

wave_sprite := l_load_image("res/water-wave-bigger.png", (128, 128))

waves :: fn layer: int -> void {
    layer := as_float(layer)
    time := layer * 1.234 + l_time()

    for i := -10, i <= 10, i += 1 {
        scale := 0.9 / (layer + 1.0)
        x := as_float(i) * scale + sin(time * 0.5) * 0.05

        offset := layer / 3.0 - 0.7
        if layer == 2.0 {
            offset -= 0.1
        }

        scale_x := scale
        if layer == 1.0 {
            scale_x *= -1.0
        }

        y := offset + cos(time * 1.2) * 0.02
        l_gfx_sprite! wave_sprite, (0, 0), x, y, scale_x, scale
    }
}

water_background := l_load_image("res/water-no-detail.png", (128, 128))

draw_game :: fn {
    l_gfx_sprite! water_background, (0, 0), 0.0, -1.1, 2.0, 2.0

    for layer := 2, layer >= 0, layer -= 1 {
        waves(layer)
        for i := 0, i < len(fishes), i += 1 {
            if fishes[i].layer == layer {
                fishes[i].draw!
            }
        }
    }

    stack_x := -0.65
    stack_y := -0.8

    for i := 0, i < len(frisbee_stack), i += 1 {
        y := stack_y + 0.1 * as_float(i)
        f := frisbee_stack[i]
        f.draw_stacked! stack_x, y, 1.0
    }

    if !out_of_frisbees {
        frisbee.draw!
    }
}

start :: fn {
    init!

    fs := store_mod.store_init!

    init_store : !fn -> void = fs[0]
    update_store : !fn float -> void = fs[1]
    draw_store : !fn -> void = fs[2]

    init_store!

    for _ in inf(0) {
        _
        if l_input_down("quit") {
            break
        }

        l_update!

        if game_state == GAME_STATE_PLAYING {
            update_game! l_delta!
            draw_game!
        }
        if game_state == GAME_STATE_STORE {
            update_store! l_delta!
            draw_store!
        }

        font_mod.draw_num! 0.5, 0.0, 0.1, FONT_PLUS, 205, FONT_DOLLAR

        curtain_mod.curtain_update! l_delta!
        curtain_mod.curtain_draw!

        l_render!
    }
}
